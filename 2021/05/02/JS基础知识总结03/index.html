<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="lufei">





<title>JS基础知识和拓展案例 | lufei</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">bravefei</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">笔记</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">bravefei</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">笔记</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JS基础知识和拓展案例</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">lufei</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">五月 2, 2021&nbsp;&nbsp;11:21:16</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="JS基础知识总结"><a href="#JS基础知识总结" class="headerlink" title="JS基础知识总结"></a>JS基础知识总结</h1><h3 id="JavaScript的作用域"><a href="#JavaScript的作用域" class="headerlink" title="JavaScript的作用域"></a>JavaScript的作用域</h3><p>JavaScript作用域</p>
<p>就是代码名字（变量）在某个范围内起作用和效果 目的是为了提高程序的可靠性更重要的是减少命名冲突</p>
<p>js的作用域（es6）之前 ： 全局作用域  局部作用域 </p>
<ul>
<li><p>全局作用域： 整个script标签 或者是一个单独的js文件</p>
</li>
<li><p>局部作用域（函数作用域） 在函数内部就是局部作用域 这个代码的名字只在函数内部起效果和作用</p>
</li>
</ul>
<p><strong>变量的作用域</strong></p>
<p>根据作用域的不同我们变量分为全局变量和局部变量</p>
<p>全局变量：</p>
<ul>
<li><p>在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量)</p>
</li>
<li><p>全局变量在代码的任何位置都可以使用</p>
</li>
<li><p>在全局作用域下var 声明的变量是全局变量</p>
</li>
</ul>
<blockquote>
<p>注意：如果在函数内部 没有声明直接赋值的变量也属于全局变量</p>
</blockquote>
<p>局部变量：</p>
<ul>
<li><p>在局部作用域下声明的变量叫做局部变量(在函数内部定义的变量)</p>
</li>
<li><p>局部变量只能在该函数内部使用</p>
</li>
<li><p>在函数内部var声明的变量是局部变量</p>
</li>
</ul>
<blockquote>
<p>注意： 函数的形参也可以看做是局部变量</p>
</blockquote>
<p>从执行效率来看全局变量和局部变量</p>
<p>​        (1) 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源</p>
<p>​        (2) 局部变量 当我们程序执行完毕就会销毁， 比较节约内存资源</p>
<blockquote>
<p>注意：现阶段js 没有 块级作用域，js 在 es6 有新增的块级作用域</p>
</blockquote>
<p>作用域链</p>
<p>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取那个值 这种结构我们称为作用域链，（就近原则）</p>
<h3 id="JavaScript预解析"><a href="#JavaScript预解析" class="headerlink" title="JavaScript预解析"></a>JavaScript预解析</h3><p>JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步：预解析和代码执行。</p>
<p>预解析：js引擎运行js 分为两步： 预解析 代码执行</p>
<p>​        (1) 预解析 js引擎会把js 里面所有的 var（声明）  还有 function（函数） 提升到当前作用域的最前面</p>
<p>​        (2) 代码执行 按照代码书写的顺序从上往下执行</p>
<p>预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升）</p>
<p>​        (1) 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作</p>
<p>​        (2) 函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数</p>
<p>JS预解析案例拓展：</p>
<p>进行JS预解析和变量声明提升</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(num); // undefined  坑 1</span><br><span class="line">var num = 10;</span><br><span class="line">// 相当于执行了以下代码</span><br><span class="line">// var num;</span><br><span class="line">// console.log(num);</span><br><span class="line">// num = 10;</span><br></pre></td></tr></table></figure>



<p>进行JS预解析，函数声明提升</p>
<p>fun(); // 报错 坑2 调用时前面无fun()函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fun = function () &#123;</span><br><span class="line">	console.log(22);</span><br><span class="line">&#125;</span><br><span class="line"> // 函数表达式 调用必须写在函数表达式的下面</span><br><span class="line">// 相当于执行了以下代码</span><br><span class="line">// var fun;</span><br><span class="line">// fun();</span><br><span class="line">// fun = function() &#123;</span><br><span class="line">//     console.log(22);</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>



<p>进行函数声明提升</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line">function fn() &#123;</span><br><span class="line">	console.log(11);</span><br><span class="line">&#125;</span><br><span class="line">// 相当于执行了以下代码</span><br><span class="line">// function fn() &#123;</span><br><span class="line">//     console.log(22);</span><br><span class="line">// &#125;</span><br><span class="line">// fn();</span><br></pre></td></tr></table></figure>



<p>重点案例：集体声明时，只有第一个值为var 声明赋值，其余值全部为全局变量赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fn();</span><br><span class="line">console.log(c);  // 9</span><br><span class="line">console.log(b);  // 9</span><br><span class="line">console.log(a);  // 报错</span><br><span class="line">function fn() &#123;</span><br><span class="line">var a = b = c = 9;</span><br><span class="line">console.log(a);  // 9</span><br><span class="line">console.log(b);  // 9</span><br><span class="line">console.log(c);  // 9</span><br><span class="line">&#125;</span><br><span class="line">// 相当于执行以下代码</span><br><span class="line">// function fn() &#123;</span><br><span class="line">//   var a;</span><br><span class="line">//   a = b = c = 9;</span><br><span class="line">//   // 相当于 var a = 9; b = 9; c = 9; b 和 c 直接赋值，没有var 声明当全局变量看</span><br><span class="line">//   // 集体声明  var a = 9, b = 9, c = 9;</span><br><span class="line">//   console.log(a);  // 9</span><br><span class="line">//   console.log(b);  // 9</span><br><span class="line">//   console.log(c);  // 9</span><br><span class="line">// &#125;</span><br><span class="line">// fn();</span><br><span class="line">// console.log(c);  // 9</span><br><span class="line">// console.log(b);  // 9</span><br><span class="line">// console.log(a);  // 报错</span><br></pre></td></tr></table></figure>



<h3 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h3><p>对象是一个具体的事物，看得见摸得着的实物。</p>
<p>在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p>
<p>对象是由属性和方法组成的。</p>
<ul>
<li><p>属性∶事物的特征，在对象中用属性来表示(常用名词)</p>
</li>
<li><p>方法：事物的行为，在对象中用方法来表示(常用动词)</p>
</li>
</ul>
<p><strong>对象的创建：</strong></p>
<p>在JavaScript中，现阶段我们可以采用三种方式创建对象( object ) :</p>
<p>利用字面量创建对象；利用new Object创建对象；利用构造函数创建对象</p>
<p><strong>字面量创建对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;  // 创建了一个空的对象</span><br><span class="line">var obj = &#123; 属性名: 属性值, 属性名: 属性值... &#125;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    uname: &#x27;张三疯&#x27;,</span><br><span class="line">    age: 18,</span><br><span class="line">    sex: &#x27;男&#x27;,</span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line">    	console.log(&#x27;hi~&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 里面的属性或者方法我们采取键值对的形式  键 属性名 ： 值  属性值 </p>
<p>(2) 多个属性或者方法中间用逗号隔开的</p>
<p>(3) 方法冒号后面跟的是一个匿名函数</p>
<p>对象的调用:</p>
<ul>
<li><p>对象里面的属性调用：对象.属性名，这个小点.就理解为“的”</p>
</li>
<li><p>象里面属性的另一种调用方式:对象[‘属性名’]，&gt; 注意方括号里面的属性必须加引号，    对象里面的方法调用∶对象.方法名()，&gt; 注意这个方法名字后面一定加括号</p>
</li>
</ul>
<p><strong>new Object创建对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object(); // 创建了一个空的对象</span><br><span class="line">var obj = new Object(); </span><br><span class="line">obj.uname = &#x27;张三疯&#x27;;</span><br><span class="line">obj.age = 18;</span><br><span class="line">obj.sex = &#x27;男&#x27;;</span><br><span class="line">obj.sayHi = function() &#123;</span><br><span class="line">	console.log(&#x27;hi~&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 我们是利用 等号 = 赋值的方法 添加对象的属性和方法</p>
<p>(2) 每个属性和方法之间用 分号结束</p>
<p><strong>构造函数创建对象</strong></p>
<p>因为我们一次创建一个对象，里面很多的属性和方法是大量相同的 我们只能复制 </p>
<p>因此我们可以利用函数的方法 重复这些相同的代码 我们就把这个函数称为 构造函数</p>
<p>又因为这个函数不一样，里面封装的不是普通代码，而是 对象 </p>
<p>构造函数 就是把对象里面一些相同的属性和方法抽象出来封装到函数里面</p>
<p>构造函数的语法格式</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function 构造函数名() &#123; //构造函数名首字母大写</span><br><span class="line">this.属性 = 值;</span><br><span class="line">	this.方法 = function() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new 构造函数名();</p>
<ol>
<li><p>构造函数名字首字母要大写</p>
</li>
<li><p>我们构造函数不需要return 就可以返回结果</p>
</li>
<li><p>我们调用构造函数 必须使用 new</p>
</li>
<li><p>我们只要new Star() 调用函数就创建一个对象 ldh  {}</p>
</li>
<li><p>我们的属性和方法前面必须添加 this 进行接收</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Star(uname, age, sex) &#123;</span><br><span class="line">    this.name = uname;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.sing = function(sang) &#123;</span><br><span class="line">    	console.log(sang);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ldh = new Star(&#x27;刘德华&#x27;, 18, &#x27;男&#x27;);</span><br><span class="line">console.log(ldh.name);</span><br><span class="line">console.log(ldh[&#x27;sex&#x27;]);</span><br></pre></td></tr></table></figure>



<p><strong>构造函数和对象</strong></p>
<p>构造函数  明星 泛指的某一大类  它类似于 java 语言里面的  类(class)</p>
<p>创建对象，如new Stars)，特指某一个，通过new关键字创建对象的过程我们也称为对象实例化</p>
<p>构造函数中new 关键字的执行过程</p>
<p>new在执行时会做四件事情:</p>
<ol>
<li><p>在内存中创建一个新的空对象。</p>
</li>
<li><p>让this指向这个新的对象。</p>
</li>
<li><p>执行构造函数里面的代码，给这个新对象添加属性和方法。</p>
</li>
<li><p>返回这个新对象（所以构造函数里面不需要return )。</p>
</li>
</ol>
<p><strong>遍历对象</strong></p>
<p>for…in语句用于对数组或者对象的属性进行循环操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var k in obj) &#123;</span><br><span class="line">    console.log(k); // k 变量 输出  得到的是 属性名</span><br><span class="line">    console.log(obj[k]); // obj[k] 得到是 属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 for…in 里面的变量 我们喜欢写 k  或者  key</p>
<p><strong>变量、属性、函数、方法的区别：</strong></p>
<p>变量和属性的相同点 他们都是用来存储数据的</p>
<p>变量 单独声明并赋值  使用的时候直接写变量名 单独存在</p>
<p>属性 在对象里面的不需要声明的 使用的时候必须是 对象.属性</p>
<p>函数和方法的相同点 都是实现某种功能  做某件事</p>
<p>函数是单独声明 并且调用的 函数名() 单独存在的</p>
<p>方法 在对象里面 调用的时候 对象.方法()</p>
<p><strong>对象总结</strong></p>
<ol>
<li><p>对象可以让代码结构更清晰</p>
</li>
<li><p>对象复杂数据类型object。</p>
</li>
<li><p>本质∶对象就是一组无序的相关属性和方法的集合。</p>
</li>
<li><p>构造函数泛指某一大类，比如苹果，不管是红色苹果还是绿色苹果，都统称为苹果</p>
</li>
<li><p>对象实例特指一个事物，比如这个苹果、正在给你们讲课的老师等。</p>
</li>
<li><p>for …in语句用于对对象的属性进行循环操作。</p>
</li>
</ol>
<p><strong>JS对象拓展案例：</strong></p>
<p>判断是否有该属性 对象[‘属性名’]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">	age: 18</span><br><span class="line">&#125;</span><br><span class="line">if (o[&#x27;sex&#x27;]) &#123; // 判断对象中是否有某个属性</span><br><span class="line">	console.log(&#x27;里面有该属性&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	console.log(&#x27;没有该属性&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JavaScript内置对象"><a href="#JavaScript内置对象" class="headerlink" title="JavaScript内置对象"></a><strong>JavaScript内置对象</strong></h3><p>JavaScript中的对象分为3种:自定义对象、内置对象、浏览器对象</p>
<p>前面两种对象是js基础内容，属于ECMAScript；第三个浏览器对象属于JS独有，在JS API讲解</p>
<p>内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法)</p>
<p>JavaScript提供了多个内置对象∶Math、Date . Array、String等</p>
<p>查文档</p>
<p>学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。</p>
<p>Mozilla开发者网络(MDN )提供了有关开放网络技术(Open Web )的信息，包括HTML、CSS和万维网及HTML5应用的 API。</p>
<p>MDN: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p>
<p>如何学习对象中的方法</p>
<ol>
<li><p>查阅该方法的功能</p>
</li>
<li><p>查看里面参数的意义和类型</p>
</li>
<li><p>查看返回值的意义和类型</p>
</li>
<li><p>通过demo进行测试</p>
</li>
</ol>
<p><strong>Math对象</strong></p>
<p>Math是一个内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。</p>
<p>Math数学对象 不是一个构造函数 ，所以我们不需要new 来调用 而是直接使用里面的属性和方法即可</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Math.PI</td>
<td>圆周率</td>
</tr>
<tr>
<td>Math.max(1， 2， 3);</td>
<td>求1，2，3中的最大值，如果没有参数，则结果为-Infinity，如果有任一参数不能被转换为数值，则结果为NaN</td>
</tr>
<tr>
<td>Math.abs();</td>
<td>取绝对值，隐式转换 会把字符串型 “-1” 转换为数字型</td>
</tr>
<tr>
<td>Math.floor();</td>
<td>向下取整，往小了取，有小数去除小数位</td>
</tr>
<tr>
<td>Math.ceil();</td>
<td>向上取整，往大了取，有小数个位数 +1</td>
</tr>
<tr>
<td>Math.round();</td>
<td>四舍五入，但是 .5 特殊 它往大了取。console.log(Math.round(1.5)); // 2。console.log(Math.round(-1.5)); // -1</td>
</tr>
<tr>
<td>Math.random();</td>
<td>取随机数, random() 返回一个随机的小数  0 =&lt; x &lt; 1</td>
</tr>
<tr>
<td>Math.floor(Math.random() * (max - min + 1)) + min;</td>
<td>两个数之间随机数</td>
</tr>
</tbody></table>
<p>案例：求两个数之间的随机数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">	return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getRandom(1, 10));</span><br></pre></td></tr></table></figure>

<p>案例：随机点名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;, &#x27;赵六&#x27;, &#x27;刘七&#x27;];</span><br><span class="line">// console.log(arr[0]);</span><br><span class="line">// console.log(arr[getRandom(0, 4)])</span><br><span class="line">console.log(arr[getRandom(0, arr.length - 1)]);</span><br></pre></td></tr></table></figure>

<p>案例：猜数字游戏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">	return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br><span class="line">var random = getRandom(1, 10);</span><br><span class="line">while (true) &#123; // 避免死循环，正确时退出循环</span><br><span class="line">    var num = prompt(&#x27;你来猜？ 输入1~10之间的一个数字&#x27;);</span><br><span class="line">    if (num &gt; random) &#123;</span><br><span class="line">        alert(&#x27;你猜大了&#x27;);</span><br><span class="line">    &#125; else if (num &lt; random) &#123;</span><br><span class="line">        alert(&#x27;你猜小了&#x27;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&#x27;你好帅哦，猜对了&#x27;);</span><br><span class="line">        break; // 退出整个循环结束程序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><p>Date() 日期对象  是一个构造函数 必须使用new 来调用创建我们的日期对象</p>
<p>var date = new Date(); // Date实例用来处理日期和时间</p>
<ol>
<li><p>使用Date  如果没有参数 返回当前系统的当前时间</p>
</li>
<li><p>带参数常用的写法  数字型  2019, 10, 01  或者是 字符串型 ‘2019-10-1 8:8:8’</p>
</li>
</ol>
<p>如果括号里面有时间，就返回参数里面的时间。例做旧期格式字符串为‘2019-5-1’可以写成newDate(2019-5-1’)或者new Date(2019/5/1)</p>
<p><strong>日期格式化</strong></p>
<p>需要获取日期指定的部分，所以我们要手动的得到这种格式。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>getFullYear()</td>
<td>获取当年</td>
<td>Date.getFullYear()</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取当月(0-11)</td>
<td>Date.getMonth()</td>
</tr>
<tr>
<td>getDate()</td>
<td>获取当天日期</td>
<td>Date.getDate()</td>
</tr>
<tr>
<td>getDay()</td>
<td>获取星期几(周日0到周六6)</td>
<td>Date.getDay()</td>
</tr>
<tr>
<td>getHours()</td>
<td>获取当前小时</td>
<td>Date.getHours()</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>获取当前分钟</td>
<td>Date.getMinutes()</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>获取当前秒钟</td>
<td>Date.getSeconds()</td>
</tr>
</tbody></table>
<p>案例：返回当前年，月，日，星期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var year = date.getFullYear();</span><br><span class="line">var month = date.getMonth() + 1;</span><br><span class="line">var dates = date.getDate();</span><br><span class="line">var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;];</span><br><span class="line">var day = date.getDay();</span><br><span class="line">console.log(&#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day]);</span><br></pre></td></tr></table></figure>

<p>案例：封装一个函数返回当前的时分秒 格式 08:08:08</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getTimer() &#123;</span><br><span class="line">    var time = new Date();</span><br><span class="line">    var h = time.getHours();</span><br><span class="line">    h = h &lt; 10 ? &#x27;0&#x27; + h : h;</span><br><span class="line">    var m = time.getMinutes();</span><br><span class="line">    m = m &lt; 10 ? &#x27;0&#x27; + m : m;</span><br><span class="line">    var s = time.getSeconds();</span><br><span class="line">    s = s &lt; 10 ? &#x27;0&#x27; + s : s;</span><br><span class="line">    return h + &#x27;:&#x27; + m + &#x27;:&#x27; + s;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getTimer());</span><br></pre></td></tr></table></figure>

<p><strong>获取曰期的总的毫秒形式</strong></p>
<p>Date对象是基于1970年1月1日（世界标准时间）起的</p>
<p>我们经常利用总的毫秒数来计算时间，因为它更精确</p>
<ol>
<li>通过 valueOf()  getTime() 获得Date总的毫秒数(时间戳)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">console.log(date.valueOf()); </span><br><span class="line">console.log(date.getTime());</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>简单的写法 (最常用的写法)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var date = +new Date(); // 为空返回当前的总毫秒数，不为空返回输入的总毫秒数</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>H5 新增的 获得总的毫秒数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Date.now()); // 当前时间戳</span><br></pre></td></tr></table></figure>



<p><strong>拓展案例：</strong></p>
<p>输入的时间减去现在的时间就是剩余的时间，即倒计时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function countDown(time) &#123;</span><br><span class="line">    var nowTime = +new Date(); // 返回的是当前时间总的毫秒数</span><br><span class="line">    var inputTime = +new Date(time); // 返回的是用户输入时间总的毫秒数</span><br><span class="line">    var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 </span><br><span class="line">    var d = parseInt(times / 60 / 60 / 24); // 天</span><br><span class="line">    d = d &lt; 10 ? &#x27;0&#x27; + d : d;</span><br><span class="line">    var h = parseInt(times / 60 / 60 % 24); //时</span><br><span class="line">    h = h &lt; 10 ? &#x27;0&#x27; + h : h;</span><br><span class="line">    var m = parseInt(times / 60 % 60); // 分</span><br><span class="line">    m = m &lt; 10 ? &#x27;0&#x27; + m : m;</span><br><span class="line">    var s = parseInt(times % 60); // 当前的秒</span><br><span class="line">    s = s &lt; 10 ? &#x27;0&#x27; + s : s;</span><br><span class="line">    return d + &#x27;天&#x27; + h + &#x27;时&#x27; + m + &#x27;分&#x27; + s + &#x27;秒&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(countDown(&#x27;2050-1-1 00:00:00&#x27;));</span><br></pre></td></tr></table></figure>



<h4 id="Array对象（数组）"><a href="#Array对象（数组）" class="headerlink" title="Array对象（数组）"></a>Array对象（数组）</h4><p>数组的创建</p>
<ol>
<li>利用数组字面量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">console.log(arr[0]);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用new Array()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = new Array(); // 创建了一个空的数组</span><br><span class="line">var arr1 = new Array(2); // 这个2 表示 数组的长度为 2  里面有2个空的数组元素</span><br></pre></td></tr></table></figure>

<p>判断是否为数组</p>
<ol>
<li>参数 instanceof Array; 运算符 它可以用来检测是否为数组</li>
</ol>
<p><code>console.log(arr instanceof Array);</code> 如果是数组返回值为true，不是数组返回值为false</p>
<ol start="2">
<li>Array.isArray(参数);  H5新增的方法  ie9以上版本支持</li>
</ol>
<p><code>console.log(Array.isArray(arr));</code> 如果是数组返回值为true，不是数组返回值为false</p>
<p><strong>数组元素添加删除</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>push(参数1….)</td>
<td>末尾添加一个或多个元素，&gt; 注意修改原数组</td>
<td>并返回新的长度</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组最后一个元素，把数组长度减1无参数、修改原数组</td>
<td>返回它删除的元素的值</td>
</tr>
<tr>
<td>unshift(参数1…)</td>
<td>向数组的开头添加一个或更多元素，&gt; 注意修改原数组</td>
<td>并返回新的长度</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的第一个元素，数组长度减1无参数、修改原数组</td>
<td>返回第一个元素的值</td>
</tr>
</tbody></table>
<p>添加：push(末尾添加);  unshift(首添加);</p>
<p>​        push 是可以给数组末尾追加新的元素</p>
<p>​        push() 参数直接写 数组元素就可以了，push完毕之后，返回的结果是新数组的长度，原数组也会发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">console.log(arr.push(4, 5));</span><br></pre></td></tr></table></figure>

<p>unshift是可以给数组前面追加新的元素</p>
<p>​        unshift() 参数直接写 数组元素就可以了,unshift完毕之后，返回的结果是新数组的长度 ,原数组也会发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.unshift(&#x27;red&#x27;, &#x27;blue&#x27;));</span><br></pre></td></tr></table></figure>

<p>删除：pop(末尾删除);  shift(首删除);</p>
<p>​        pop是可以删除数组的最后一个元素 记住一次只能删除一个元素</p>
<p>​        pop() 没有参数， pop完毕之后，返回的结果是删除的那个元素 ，原数组也会发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.pop());</span><br></pre></td></tr></table></figure>

<p> shift是可以删除数组的第一个元素 记住一次只能删除一个元素</p>
<p>​        shift() 没有参数，shift完毕之后，返回的结果是删除的那个元素，原数组也会发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.shift());</span><br></pre></td></tr></table></figure>

<p><strong>数组添加删除拓展案例：</strong></p>
<p>把数组中工资超过2000的删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1500, 1200, 2000, 2100, 1800];</span><br><span class="line">var newArr = [];</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (arr[i] &lt; 2000) &#123;</span><br><span class="line">    	newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(newArr);</span><br></pre></td></tr></table></figure>

<p><strong>数组排序</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否修改原数组</th>
</tr>
</thead>
<tbody><tr>
<td>reverse()</td>
<td>颠倒数组中元素的顺序，无参数</td>
<td>该方法会改变原来的数组返回新数组</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序</td>
<td>该方法会改变原来的数组返回新数组</td>
</tr>
</tbody></table>
<ol>
<li>翻转数组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;pink&#x27;, &#x27;red&#x27;, &#x27;blue&#x27;];</span><br><span class="line">arr.reverse();</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组排序（冒泡排序）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [13, 4, 77, 1, 7];</span><br><span class="line">arr1.sort(function(a, b) &#123;</span><br><span class="line">    // return a - b; 升序的顺序排列</span><br><span class="line">    return b - a; // 降序的顺序排列</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr1);</span><br></pre></td></tr></table></figure>

<p><strong>数组的索引方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>indexOf()</td>
<td>数组中查找给定元素的第一个索引</td>
<td>如果存在返回索引号如果不存在，则返回-1</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在数组中的最后一个的索引</td>
<td>如果存在返回索引号如果不存在，则返回-1</td>
</tr>
<tr>
<td>indexOf(数组元素)</td>
<td>作用就是返回该数组元素的索引号，从前面开始查找</td>
<td>返回第一个满足条件的索引号，它如果在该数组里面找不到元素，则返回的是 -1</td>
</tr>
<tr>
<td>lastIndexOf(数组元素)</td>
<td>作用就是返回该数组元素的索引号 从后面开始查找</td>
<td>返回第一个满足条件的索引号，它如果在该数组里面找不到元素，则返回的是 -1</td>
</tr>
</tbody></table>
<p><strong>数组索引拓展案例：</strong></p>
<p>把旧数组里面不重复的元素选取出来放到新数组中， 重复的元素只保留一个， 放到新数组中去重</p>
<p>核心算法： 遍历旧数组， 然后拿着旧数组元素去查询新数组， 如果该元素在新数组里面没有出现过， 我们就添加， 否则不添加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var newArr = [];</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (newArr.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br><span class="line">var demo = unique([&#x27;blue&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;])</span><br><span class="line">console.log(demo);</span><br></pre></td></tr></table></figure>

<p><strong>数组转换为字符串</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>把数组转换成字符串，逗号分隔每一项</td>
<td>返回一个字符串</td>
</tr>
<tr>
<td>join(“分隔符”)</td>
<td>方法用于把数组中的所有元素转换为一个字符串</td>
<td>返回一个字符串</td>
</tr>
</tbody></table>
<p>toString() 将我们的数组转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">console.log(arr.toString()); // 1,2,3</span><br></pre></td></tr></table></figure>

<p>join(分隔符) </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;];</span><br><span class="line">console.log(arr1.join()); // green,blue,pink</span><br><span class="line">console.log(arr1.join(&#x27;&amp;&#x27;)); // green&amp;blue&amp;pink</span><br></pre></td></tr></table></figure>



<p><strong>数组中常用的其他方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组不影响原数组</td>
<td>返回一个新的数组</td>
</tr>
<tr>
<td>slice()</td>
<td>数组截取slice(start, end)</td>
<td>返回被截取项目的新数组</td>
</tr>
<tr>
<td>splice()</td>
<td>数组删除splice(第几个开始,要删除个数)</td>
<td>返回被删除项目的新数组。&gt; 注意：这个会影响原数组</td>
</tr>
</tbody></table>
<p>concat() 连接两个或多个数组不影响原数组，返回一个新的数组不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。</p>
<p>使用方法 arr1.concat(arr2); 把arr2数组拼接到arr1数组的后面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function cat(arr1, arr2) &#123;</span><br><span class="line">    var newArr = arr1.concat(arr2);</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(cat([1, 2, 3], [4, 5]));</span><br></pre></td></tr></table></figure>

<p>slice() 数组截取slice(start, end)，以新的数组对象，返回数组中被选中的元素，从start开始到end结束，但不包括end，返回被截取项目的新数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6];</span><br><span class="line">var excision = arr.slice(3, 5);</span><br><span class="line">console.log(arr); // [1, 2, 3, 4, 5, 6]</span><br><span class="line">console.log(excision); // [4, 5]</span><br></pre></td></tr></table></figure>

<p>splice() 向数组添加/删除项目，并返回删除的项目，splice(第几个开始,要删除个数)，返回被删除项目的新数组&gt; 注意，这个会影响原数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;white&quot;, &quot;black&quot;, &quot;grey&quot;];</span><br><span class="line">var cat = arr.splice(3, 2);</span><br><span class="line">console.log(arr); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;grey&quot;]</span><br><span class="line">console.log(cat); // [&quot;white&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：slice() 方法不会改变原始数组，splice() 方法会改变原始数组（重点）。</p>
</blockquote>
<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p><strong>基本包装类型</strong></p>
<p>为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型:String、Number和Boolean。基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p>
<p>基本包装类型： 就是把简单数据类型包装成为了复杂数据类型，因为复杂数据类型才有属性和方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.生成临时变量，把简单类型包装为复杂数据类型</span><br><span class="line">var temp = new string ( &#x27;andy&quot; ) ;</span><br><span class="line">// 2.赋值给我们声明的字符变量</span><br><span class="line">str = temp;</span><br><span class="line">// 3.销毁临时变量</span><br><span class="line">temp = null;</span><br></pre></td></tr></table></figure>

<p>字符串的不可变：</p>
<ul>
<li><p>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</p>
</li>
<li><p>因为我们字符串的不可变所以不要大量的拼接字符串</p>
</li>
</ul>
<p><strong>根据指定字符返回位置</strong></p>
<p>字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>indexOf(“要查找的字符”,开始的位置(索引号))</td>
<td>返回指定内容在元字符串中的位置，如果找不到就返回-1</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>从后往前找，只找第一个匹配的</td>
</tr>
</tbody></table>
<p>字符串对象 根据字符返回位置 str.indexOf(‘要查找的字符’, [起始的位置即索引号])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;改革春风吹满地，春天来了&#x27;;</span><br><span class="line">console.log(str.indexOf(&#x27;春&#x27;));  // 2</span><br><span class="line">console.log(str.indexOf(&#x27;春&#x27;, 3)); // 从索引号是 3的位置开始往后查找</span><br></pre></td></tr></table></figure>

<p><strong>字符串返回位置拓展案例：</strong></p>
<p>查找字符串”abcoefoxyozopp”中所有o出现的位置以及次数。</p>
<p>核心算法:先查找第一个o出现的位置，然后只要indexOf返回的结果不是-1就继续往后查找，因为indexOf只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;oabcoefoxyozzopp&quot;;</span><br><span class="line">var index = str.indexOf(&#x27;o&#x27;);</span><br><span class="line">var num = 0;</span><br><span class="line">// console.log(index);</span><br><span class="line">while (index !== -1) &#123;</span><br><span class="line">    console.log(&quot;o出现的索引为：&quot; + index);</span><br><span class="line">    num++;</span><br><span class="line">    index = str.indexOf(&#x27;o&#x27;, index + 1); // 查询的字符串后面没有o，index的值才为-1 </span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;o出现的次数是: &#x27; + num);</span><br></pre></td></tr></table></figure>

<p><strong>根据位置返回字符</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>charAt(index)</td>
<td>返回指定位置的字符(index字符串的索引号)</td>
<td>str.charAt(0)</td>
</tr>
<tr>
<td>charCodeAt(index)</td>
<td>获取指定位置处字符的ASCII码(index索引号)</td>
<td>str.charCodeAt(0)</td>
</tr>
<tr>
<td>str[index]</td>
<td>获取指定位置处字符</td>
<td>HTML5，IE8+支持和charAt()等效</td>
</tr>
</tbody></table>
<ol>
<li>charAt(index) 根据位置返回字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;andy&#x27;;</span><br><span class="line">console.log(str.charAt(3));</span><br><span class="line">// 遍历所有的字符</span><br><span class="line">for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">  	console.log(str.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>charCodeAt(index)  返回相应索引号的字符ASCII值 目的： 判断用户按下了那个键 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(str.charCodeAt(0)); // 97</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>str[index] H5 新增的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(str[0]); // a</span><br></pre></td></tr></table></figure>



<p><strong>字符串对象拓展案例：</strong></p>
<p>判断一个字符串”abcoefoxyozzopp’中出现次数最多的字符，并统计其次数。</p>
<p>核心算法：利用charA(）遍历这个字符串，把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 遍历对象，得到最大值和该字符</span><br><span class="line">var str = &#x27;abcoefoxyozzopp&#x27;;</span><br><span class="line">var o = &#123;&#125;;</span><br><span class="line">for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">    var chars = str.charAt(i); // chars 是 字符串的每一个字符</span><br><span class="line">    if (o[chars]) &#123; // o[chars] 得到的是属性值</span><br><span class="line">    	o[chars]++; // 有o.chars属性，0.chars的属性值+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	o[chars] = 1; // 没有o.chars属性，0.chars的属性值赋值为1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(o);</span><br><span class="line">// 遍历对象，获取最大值</span><br><span class="line">var max = 0;</span><br><span class="line">var ch = &#x27;&#x27;;</span><br><span class="line">for (var k in o) &#123;  // k 得到是 属性名，o为对象，o[k] 得到的是属性值</span><br><span class="line">    if (o[k] &gt; max) &#123;</span><br><span class="line">        max = o[k]; //</span><br><span class="line">        ch = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(max);</span><br><span class="line">console.log(&#x27;最多的字符是&#x27; + ch);</span><br></pre></td></tr></table></figure>



<p><strong>字符串的操作方法（重点）</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat(str1,str2,str3…)</td>
<td>concat()方法用于连接两个或多个字符串。拼接字符串，等效于+，+更常用</td>
</tr>
<tr>
<td>substr(start,length)</td>
<td>从start位置开始（索引号) , length取的个数<strong>（重点）</strong></td>
</tr>
<tr>
<td>slice(start, end)</td>
<td>从start位置开始，截取到end位置，end取不到(他们俩都是索引号)</td>
</tr>
<tr>
<td>substring(start, end)</td>
<td>从start位置开始，截取到end位置，end取不到基本和slice相同但是不接受负值</td>
</tr>
</tbody></table>
<p> arr.concat(‘字符串1’,’字符串2’….) 字符串拼接在arr的后面拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;andy&#x27;;</span><br><span class="line">console.log(str.concat(&#x27;red&#x27;));</span><br></pre></td></tr></table></figure>

<p>substr(‘截取的起始位置’, ‘截取几个字符’);</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &#x27;改革春风吹满地&#x27;;</span><br><span class="line">console.log(str1.substr(2, 2)); // 第一个2 是索引号 第二个2 是取几个字符</span><br></pre></td></tr></table></figure>

<p><strong>字符串拼接和转换数组操作</strong></p>
<p>替换字符 replace(‘被替换的字符’, ‘替换为的字符’) 它只会替换第一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;andyandy&#x27;;</span><br><span class="line">console.log(str.replace(&#x27;a&#x27;, &#x27;b&#x27;)); //bndyandy</span><br><span class="line">// 有一个字符串 &#x27;abcoefoxyozzopp&#x27; 要求把里面所有的 o 替换为 *</span><br><span class="line">var str1 = &#x27;abcoefoxyozzopp&#x27;;</span><br><span class="line">while (str1.indexOf(&#x27;o&#x27;) !== -1) &#123;</span><br><span class="line">	str1 = str1.replace(&#x27;o&#x27;, &#x27;*&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(str1);</span><br></pre></td></tr></table></figure>

<p>字符转换为数组 split(‘分隔符’)  前面我们学过.join 把数组转换为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str2 = &#x27;red, pink, blue&#x27;;</span><br><span class="line">console.log(str2.split(&#x27;,&#x27;)); // [red, pink, blue] 利用字符串中 ” , ” 进行分割</span><br><span class="line">var str3 = &#x27;red&amp;pink&amp;blue&#x27;;</span><br><span class="line">console.log(str3.split(&#x27;&amp;&#x27;)); // [red, pink, blue] 利用字符串中 “ &amp; ” 进行分割</span><br></pre></td></tr></table></figure>

<p>其他字符串操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase() //转换大写</span><br><span class="line">toLowerCase()  //转换小写</span><br></pre></td></tr></table></figure>



<h4 id="封装对象"><a href="#封装对象" class="headerlink" title="封装对象"></a>封装对象</h4><p>利用对象封装自己的数学对象 里面有 PI 最大值和最小值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var myMath = &#123;</span><br><span class="line">    PI: 3.141592653,</span><br><span class="line">    max: function() &#123;</span><br><span class="line">        var max = arguments[0];</span><br><span class="line">        for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            if (arguments[i] &gt; max) &#123;</span><br><span class="line">                max = arguments[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;,</span><br><span class="line">    min: function() &#123;</span><br><span class="line">        var min = arguments[0];</span><br><span class="line">        for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            if (arguments[i] &lt; min) &#123;</span><br><span class="line">            	min = arguments[i];</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">		return min;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line">console.log(myMath.PI);</span><br><span class="line">console.log(myMath.max(1, 5, 9));</span><br><span class="line">console.log(myMath.min(1, 5, 9));</span><br></pre></td></tr></table></figure>



<h3 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h3><h4 id="简单数据类型和复杂数据类型"><a href="#简单数据类型和复杂数据类型" class="headerlink" title="简单数据类型和复杂数据类型"></a>简单数据类型和复杂数据类型</h4><p>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。</p>
<p>简单数据类型（值类型）</p>
<p>简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型string , number , boolean, undefined , null</p>
<blockquote>
<blockquote>
<p>注意：null 返回的是一个空的对象 object，如果有个变量我们以后打算存储为对象，暂时没想好放啥， 这个时候就给 null</p>
</blockquote>
</blockquote>
<p>复杂数据类型（引用类型）</p>
<p>复杂数据类型（引用类型）︰在存储时变量中存储的仅仅是地址(引用），因此叫做引用数据类型，通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等</p>
<h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>堆栈空间分配区别:</p>
<ol>
<li><p>栈(操作系统）︰由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。（简单数据类型存放到栈里面）</p>
</li>
<li><p>堆(操作系统）∶存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。（复杂数据类型存放到堆里面）</p>
</li>
</ol>
<p>JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式</p>
<p><strong>存储分配</strong></p>
<p>简单数据类型 是存放在栈里面 里面直接开辟一个空间存放的是值</p>
<p>复杂数据类型 首先在栈里面存放地址 十六进制表示 然后这个地址指向堆里面的数据</p>
<p><strong>传参</strong></p>
<p>简单数据类型传参</p>
<p>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn(a) &#123; // 通过形参 a 传参 x</span><br><span class="line">    a++;</span><br><span class="line">    console.log(a); // 11</span><br><span class="line">&#125;</span><br><span class="line">var x = 10;</span><br><span class="line">fn(x);</span><br><span class="line">console.log(x); // 10</span><br></pre></td></tr></table></figure>



<p><strong>复杂数据类型传参</strong></p>
<p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123; // 通过name 传参 “刘德华”</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function f1(x) &#123; // 通过 x 传参  p</span><br><span class="line">    console.log(x.name); // 2. 这个输出什么 ? 刘德华  </span><br><span class="line">    x.name = &quot;张学友&quot;;</span><br><span class="line">    console.log(x.name); // 3. 这个输出什么 ?  张学友</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;刘德华&quot;);</span><br><span class="line">console.log(p.name); // 1. 这个输出什么 ?  刘德华 </span><br><span class="line">f1(p);</span><br><span class="line">console.log(p.name); // 4. 这个输出什么 ?  张学友</span><br></pre></td></tr></table></figure>



<h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="解释型语言和编译语言"><a href="#解释型语言和编译语言" class="headerlink" title="解释型语言和编译语言"></a><strong>解释型语言和编译语言</strong></h3><p>翻译器翻译的方式有两种:一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</p>
<p>编译器是在代码执行之前进行编译，生成中间代码文件</p>
<p>解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)</p>
<h3 id="标识符、关键字、保留字"><a href="#标识符、关键字、保留字" class="headerlink" title="标识符、关键字、保留字"></a>标识符、关键字、保留字</h3><p>标识符：</p>
<p>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。</p>
<p>标识符不能是关键字或保留字。</p>
<p>关键字：</p>
<p>关键字：是指JS本身已经使用了的字，不能再用它们充当变量名、方法名。</p>
<p>包括: break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with等。</p>
<p>保留字：</p>
<p>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。</p>
<p>包括: boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、 short、static、super、synchronized,throws、transient、volatile等。</p>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。</p>
<p>断点调试可以帮我们观察程序的运行过程</p>
<p>浏览器中按F12–&gt; sources –&gt;找到需要调试的文件–&gt;在程序的某一行设置断点Watch:监视，通过watch可以监视变量的值的变化，非常的常用。</p>
<p>F11:程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。</p>
<p>代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/05/12/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%9304/">JS常见案例</a>
            
            
            <a class="next" rel="next" href="/2021/04/12/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%9302/">JS函数和运算</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© lufei | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>